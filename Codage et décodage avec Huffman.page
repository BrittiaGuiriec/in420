Ce DM constitue la suite du TD [Construction du code de Huffman](). Vous êtes libres d'utiliser le code que vous avez écrit pour le TD, y compris la solution qui y est fournie.

Le but de ce DM est d'écrire un programme permettant le codage et le décodage de textes par le [code de Huffman](Code de Huffman). Le texte à coder/décoder, ainsi que les fréquences d'apparition des symboles sont des entrées pour le programme. Pour simplicité, nous allons utiliser seulement les caractères (ASCII) de 'a' à 'z'.

Plus précisément, votre programme doit:

- Lire en entrée un fichier contenant les fréquences des symboles, par exemple dans le format du TD [Construction du code de Huffman]().
- Générer le code de Huffman correspondant aux fréquences fournies (déjà fait en TD).
- Offrir une option pour lire un fichier au format ASCII et l'encoder avec le code de Huffman.
- Offrir une option pour lire un fichier binaire et le décoder en un fichier ASCII avec le code de Huffman.
- Décoder correctement le [challenge](#challenge) fourni à la fin du sujet.


Dans la suite on va suggérer une façon de structurer votre code, cependant vous n'êtes pas obligés de la suivre à la lettre, tant que votre programme atteint le but recherché.


# Flux de bits

La lecture/écriture d'un fichier ASCII peut se faire aussi bien en mode binaire (avec [`FileInputStream`](http://docs.oracle.com/javase/6/docs/api/java/io/FileInputStream.html) et [`FileOutputStream`](http://docs.oracle.com/javase/6/docs/api/java/io/FileOutputStream.html)), qu'en mode texte (avec [`FileReader`](http://docs.oracle.com/javase/6/docs/api/java/io/FileReader.html) et [`FileWriter`](http://docs.oracle.com/javase/6/docs/api/java/io/FileWriter.html)). Allez voir les derniers TDs et la page [Entrées-Sorties}() en Java pour l'usage de ces classes.

Au contraire, l'encodage de Huffman est à longueur variable, et basé sur les bits. Il n'est donc pas commode de lire des fichiers encodés avec un code de Huffman en utilisant les classes par défaut de Java. La première étape consiste à créer des classes permettant de lire ou écrire un flux de données bit par bit.

Un *encapsuleur* (*wrapper* en anglais) est une classe qui prend en entrée de son constructeur un objet et qui en étend les fonctionnalités. Des exemples classiques d'encapsuleurs en Java sont [`BufferedReader`](http://docs.oracle.com/javase/6/docs/api/java/io/BufferedReader.html) et [`BufferedWriter`](http://docs.oracle.com/javase/6/docs/api/java/io/BufferedWriter.html), qui encapsulent respectivement `FileReader` et `FileWriter`, comme dans l'exemple suivant.

~~~ {.java}
BufferedReader in = new BufferedReader(new FileReader("in.txt"));
BufferedWriter out = new BufferedWriter(new FileWriter("out.txt"));
~~~

Écrire une classe `InputBitStream` qui encapsule un `InputStream`. Elle utilise le `InputStream` sous-jacent en lisant octet par octet, mais offre une interface permettant de lire un à la fois les bits de chaque octet. Elle pourra contenir, par exemple, les méthodes suivantes

- Un constructeur

    ~~~ {.java}
    public InputBitStream(InputStream in)
    ~~~

    qui prend en entrée le `InputStream` à encapsuler.

- Une méthode 

    ~~~ {.java}
    public int readBit()
    ~~~

    qui renvoie le bit suivant dans le flux (0 ou 1), ou -1 s'il n'y a plus de données dans le flux.


Dans le même esprit, écrire une classe `OutputBitStream` qui encapsule un `OutputStream`. Elle pourra contenir, par exemple, les méthodes suivantes

- Un constructeur

    ~~~ {.java}
    public OutputBitStream(OutputStream out)
    ~~~

    qui prend en entrée le `OutputStream` à encapsuler.

- Une méthode 

    ~~~ {.java}
    public void writeBit(int bit)
    ~~~

    qui écrit un bit dans le bit de sortie. Les bits à écrire doivent être gardés dans un tampon jusqu'à atteindre 8 bits, moment auquel un octet complet pourra être écrit dans le `OutputStream`.

- Une méthode

    ~~~ {.java}
    public void close()
    ~~~

    qui écrit les bits restants dans le `OutputStream`, même si le tampon n'a pas atteint les 8 bits. Après une `close`, aucune autre écriture dans le flux devrait être possible.

Pour garantir la compatibilité du code, il est opportun de se mettre d'accord sur la direction dans laquelle on lit les bits d'un octet (de gauche à droite, ou de droite à gauche). Nous allons opter pour un ordre LSB (*least significant bit*), c'est à dire d'abord les bits de *poids faible* (les plus petites puissances de deux d'abord), ou encore de droite à gauche. Si, si, je vous assure : c'est ce qui est plus pratique et naturel ! Pour faire un exemple, le texte

~~~
huffman
~~~

est encodé par les codes ASCII de ses lettres

~~~
0x68 0x75 0x66 0x66 0x6d 0x61 0x6e
~~~

ce qui, en binaire avec ordre LSB donne le flux de bits (à lire de gauche à droite)

~~~
00010110 10101110 01100110 01100110 10110110 10000110 01110110
~~~

Les séparations en blocs de 8 sont là pour vous aider à lire. Observez que pour chaque bloc de 8 bits, vous devez lire les chiffres de gauche à droite (à l'envers de ce qu'on fait d'habitude) pour obtenir les valeurs hexadécimales d'origine.


# Encoder et décoder

Le pire est passé. Maintenant que vous avez à disposition des flux de bits, encoder revient à 

- Créer le tableau d'encodage avec la méthode `createCode` du TD [Construction du code de Huffman]().
- Lire le fichier en entrée, caractère par caractère, avec un `FileReader`.
- Écrire le fichier de sortie, bit par bit, avec un `OutputBitStream`.

Décoder demande à peine plus d'effort :

- Créer l'arbre de décodage avec la méthode `createTree` du TD [Construction du code de Huffman]().
- Lire le fichier en entrée, bit par bit, avec un `InputBitStream`.
- Écrire le fichier de sortie, caractère par caractère, avec un `FileWriter`.

Le décodage est légèrement plus compliqué que l'encodage. L'algorithme consiste à parcourir l'arbre de décodage en accord avec les bits provenants du `InputBitStream` (0 correspond à aller à gauche, 1 à droite). Lorsqu'on atteint une feuille, on écrit le symbole correspondant sur la sortie.

Finalisez votre code avec un `main` qui permet de choisir le mode d'opération (encodage ou décodage), et qui prend en paramètre les noms des fichiers à lire/écrire.


# Challenge

Visitez [cette page](http://swift.prism.uvsq.fr/py/in420-dms13.py/huffman) et décodez le message fourni en suivant les instructions.

Envoyez votre code source, ainsi que le texte décodé à l'aide de la boîte de dépot sur [e-campus 2](http://e-campus2.uvsq.fr/) (si e-campus ne devait pas marcher, envoyez-les directement par mail à votre [enseignant](http://www.prism.uvsq.fr/~dfl). La date limite pour envoyer vos fichiers est le mercredi 6 mars à 4h du matin. Un point de pénalité pour chaque heure de retard: le 6 mars à 23h59 c'est votre dernière chance !

