Dans ce TD nous allons √©crire un transcodeur capable de convertir des fichiers de l'encodage [UTF-16]() √† l'encodage [UTF-8]() et *vice-versa*.

Copiez-collez le code suivant dans un fichier nomm√© `Transcoder.java`.

~~~ {.java}
import java.io.*;

public class Transcoder {
    // Constantes liees aux plages UTF-16
    private static int
        lead_start = 0xD800, 
        tail_start = 0xDC00, 
        tail_end   = 0xDFFF,
        bmp_end    = 0xFFFF,
        max_cp     = 0x10FFFF;
 
    /*
      Convertit deux mots de 16 bits (supposes encodes en UTF-16) en
      un codepoint Unicode. Le deuxieme mot est ignore le cas echeant.

      Renvoie -1 s'il y a un probleme d'encodage.
    */
    static int cp_from_UTF16(int lead, int tail) {
        return -1;
    }

    /*
      Convertit un codepoint Unicode en son encodage UTF-16 (un
      tableau de un ou deux entiers de 16 bits).

      Renvoie null si le codepoint est invalide.
     */
    static int[] cp_to_UTF16(int codepoint) {
        return null;
    }

    /*
      Convertit un codepoint Unicode en son encodage UTF-8 (un
      tableau de un a quatre entiers de 8 bits).

      Renvoie null si le codepoint est invalide.
     */
    static int[] cp_to_UTF8(int codepoint) {
        return null;
    }

    /*
      Convertit quatre mots de 8 bits (supposes encodes en UTF-8) en
      un codepoint Unicode. Les mots en plus sont ignores le cas
      echeant.

      Renvoie -1 s'il y a un probleme d'encodage.
    */
    static int cp_from_UTF8(int b1, int b2, int b3, int b4) {
        return -1;
    }

    /*
      Convertit un flux de UTF-8 a UTF-16
    */
    public static void utf8to16(InputStream in, OutputStream out) 
        throws IOException {
    }

    /*
      Convertit un flux de UTF-16 a UTF-18
    */
    public static void utf16to8(InputStream in, OutputStream out)
        throws IOException {
    }

    /*
      Cette fonction sert a tester les methodes ci-dessus. Elle prend
      un codepoint en entree et fait des affichages de test.
    */
    static void test(int codepoint) throws UnsupportedEncodingException {
        int[] utf8 = cp_to_UTF8(codepoint);
	int[] pad = new int[4];
	if (utf8 != null) {
	    byte[] code = new byte[utf8.length];
	    for (int i = 0 ; i < utf8.length ; i++) {
		pad[i] = utf8[i];
		code[i] = (byte)utf8[i];
		System.out.print(Integer.toString(utf8[i], 16) + " ");
	    }
	    System.out.println("\n" +
			       Integer.toString(cp_from_UTF8(pad[0],
							     pad[1],
							     pad[2],
							     pad[3]),
						16));
	    System.out.println(new String(code, "UTF-8"));
	}

	int[] utf16 = cp_to_UTF16(codepoint);
	if (utf16 != null) {
	    pad = new int[2];
	    for (int i = 0 ; i < utf16.length ; i++) {
		System.out.print(Integer.toString(utf16[i], 16) + " ");
		pad[i] = utf16[i];
	    }
	    System.out.println("\n" +
			       Integer.toString(cp_from_UTF16(pad[0],
							      pad[1]),
						16));
	    System.out.println("" + (char)pad[0] + (char)pad[1]);
	}
    }

    public static void main(String[] args) 
        throws IOException, UnsupportedEncodingException {

        test(Integer.parseInt(args[0], 16));
    }
}
~~~

1. Compl√©tez les m√©thodes cp_to_UTF16, cp_from_UTF16.

2. Compl√©tez les m√©thodes cp_to_UTF8, cp_from_UTF8. Ajoutez des constantes pour vous aider.

Testez a l'aide du main. Voici un exemple de sortie lorsque toutes les fonctions auront √©t√© implant√©es.

~~~
dfl@proust:~$ java Transcoder 1f603
f0 9f 98 83 
1f603
üòÉ
d83d de03 
1f603
üòÉ
~~~

3. Compl√©tez le main.

Utilisez ce lien pour visualiser vos fichiers <http://swift.prism.uvsq.fr:2401/coder.py>.

Voici la solution du TD.

<div style="overflow:hidden;height:6ex"
onclick="if (this.style.height != 'auto') this.style.height='auto'; else this.style.height='6ex'">

~~~ {.java}
import java.io.*;       // Cliquez pour voir la solution

public class Transcoder {
    // Constantes liees aux plages UTF-16
    private static int
        lead_start = 0xD800, 
        tail_start = 0xDC00, 
        tail_end   = 0xDFFF,
        bmp_end    = 0xFFFF,
        max_cp     = 0x10FFFF;
 
    /*
      Convertit deux mots de 16 bits (supposes encodes en UTF-16) en
      un codepoint Unicode. Le deuxieme mot est ignore le cas echeant.

      Renvoie -1 s'il y a un probleme d'encodage.
    */
    static int cp_from_UTF16(int lead, int tail) {
        if (lead < lead_start || lead > tail_end)
            return lead;
        else if (lead >= lead_start && lead < tail_start)
            return (lead - 0xD800) * 0x400 + (tail - 0xDC00) + 0x10000;
        else 
            return -1;
    }

    /*
      Convertit un codepoint Unicode en son encodage UTF-16 (un
      tableau de un ou deux entiers de 16 bits).

      Renvoie null si le codepoint est invalide.
     */
    static int[] cp_to_UTF16(int codepoint) {
        if (codepoint >= 0 && codepoint < bmp_end) {
            int[] pairs = { codepoint };
            return pairs;
        } else if (codepoint > bmp_end && codepoint <= max_cp) {
            int[] pairs = { (codepoint - 0x10000) / 0x400 + 0xD800,
                            (codepoint - 0x10000) % 0x400 + 0XDC00 };
            return pairs;
        } else {
            return null;
        }
    }

    // Constantes liees aux plages UTF-8
    private static int
        utf8_cp1 = 0x80,
        utf8_cp2 = 0x800,
        utf8_cp3 = 0x10000,
        utf8_cp4 = 0x200000;

    private static int
        utf8_bx = 0x80,
        utf8_b2 = 0xC0,
        utf8_b3 = 0xE0,
        utf8_b4 = 0xF0,
        utf8_b5 = 0xF8;

    /*
      Convertit un codepoint Unicode en son encodage UTF-8 (un
      tableau de un a quatre entiers de 8 bits).

      Renvoie null si le codepoint est invalide.
     */
    static int[] cp_to_UTF8(int codepoint) {
        if (codepoint >= 0 && codepoint < utf8_cp1) {
            int[] bytes = { codepoint };
            return bytes;
        } else if (codepoint < utf8_cp2) {
            int[] bytes = { codepoint / 0x40 + utf8_b2,
                      codepoint % 0x40 + utf8_bx };
            return bytes;
        } else if (codepoint < utf8_cp3) {
            int[] bytes = { codepoint / 0x40 / 0x40 + utf8_b3,
                      (codepoint / 0x40) % 0x40 + utf8_bx,
                      codepoint % 0x40 + utf8_bx };
            return bytes;
        } else if (codepoint < utf8_cp4) {
            int[] bytes = { codepoint / 0x40 / 0x40 / 0x40 + utf8_b4,
                      (codepoint / 0x40 / 0x40) % 0x40 + utf8_bx,
                      (codepoint / 0x40) % 0x40 + utf8_bx,
                      codepoint % 0x40 + utf8_bx };
            return bytes;
        } else
            return null;
    }

    /*
      Convertit quatre mots de 8 bits (supposes encodes en UTF-8) en
      un codepoint Unicode. Les mots en plus sont ignores le cas
      echeant.

      Renvoie -1 s'il y a un probleme d'encodage.
    */
    static int cp_from_UTF8(int b1, int b2, int b3, int b4) {
        if (b1 < utf8_bx)
            return b1;
        else if (b1 < utf8_b2)
            return -1;
        else if (b1 < utf8_b3 && 
                 b2 >= utf8_bx && b2 < utf8_b2)
            return (b1 % 0x20)*0x40 + (b2 % 0x40);
        else if (b1 < utf8_b4 &&
                 b2 >= utf8_bx && b2 < utf8_b2 &&
                 b3 >= utf8_bx && b3 < utf8_b2)
            return (b1 % 0x10)*0x40*0x40 + (b2 % 0x40)*0x40 + (b3 % 0x40);
        else if (b1 < utf8_b5 &&
                 b2 >= utf8_bx && b2 < utf8_b2 &&
                 b3 >= utf8_bx && b3 < utf8_b2 &&
                 b4 >= utf8_bx && b4 < utf8_b2)
            return (b1 % 0x8)*0x40*0x40*0x40 + (b2 % 0x40)*0x40*0x40 + (b3 % 0x40)*0x40 + (b4 % 0x40);
        else
            return -1;
    }

    /*
      Convertit un flux de UTF-8 a UTF-16
    */
    public static void utf8to16(InputStream in, OutputStream out)
	throws IOException {

	int b1 = in.read(), 
	    b2 = in.read(), 
	    b3 = in.read(),
	    b4;
	while (b1 != -1) {
	    b4 = in.read();
	    int cp = cp_from_UTF8(b1, b2, b3, b4);
	    if (cp != -1) {
		int[] pairs = cp_to_UTF16(cp);
		for (int i = 0 ; i < pairs.length ; i++) {
		    out.write(pairs[i] / 0x100);
		    out.write(pairs[i] % 0x100);
		}
	    }
	    b1 = b2; b2 = b3; b3 = b4;
	}
    }

    /*
      Convertit un flux de UTF-16 a UTF-18
    */
    public static void utf16to8(InputStream in, OutputStream out) 
	throws IOException {
	int b1 = in.read(), 
	    b2 = in.read(), 
	    b3, b4;

	while (b1 != -1) {
	    b3 = in.read();
	    b4 = in.read();
	    int cp = cp_from_UTF16(b1 * 0x100 + b2, b3 * 0x100 + b4);
	    if (cp != -1) {
		int[] bytes = cp_to_UTF8(cp);
		for (int i = 0 ; i < bytes.length ; i++)
		    out.write(bytes[i]);
	    }
	    b1 = b3; b2 = b4;
	}
    }

    public static void main(String[] args) 
        throws IOException, UnsupportedEncodingException {
	InputStream in = System.in;
        OutputStream out = System.out;
	int utf16 = 0;

        if (args.length >= 1 && args[0].equals("-utf16"))
	    utf16 = 1;
	if (args.length >= 1 + utf16)
	    in = new FileInputStream(args[utf16]);
        if (args.length >= 2 + utf16) 
            out = new FileOutputStream(args[1+utf16]);

	if (utf16 == 0)
	    utf8to16(in, out);
	else
	    utf16to8(in, out);
    }
}
~~~

</div>
