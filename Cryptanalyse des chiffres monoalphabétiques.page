# Cryptanalyse statistique 

Le [Chiffre de César]() fait partie de la famille des
[Chiffres monoalphabétiques](). Tous ces chiffres ont en commun une
faiblesse majeure: la vulnérabilité aux
[Attaques par analyse statistique](). En effet, dans un chiffre
monoalphabétique deux codes (i.e. lettres) identiques sont chiffrées
vers le même code. Si on sait que le texte d'origine contient des
biais statistiques (par exemple s'il s'agit d'un texte en français),
on peut retrouver la clef en cherchant ces mêmes biais dans le texte
chiffré.

Voici les tables de fréquence du français 

--- ------- --- ------ --- ------ --- ------ ----- ------
 E   15,87%  N   7,15%  D   3,39%  Q   1,06%  H     0,77%

 A    9,42%  R   6,46%  M   3,24%  G   1,04%  Z     0,32%

 I    8,41%  U   6,24%  P   2,86%  B   1,02%  X     0,30%

 S    7,90%  L   5,34%  C   2,64%  F   0,95%  Y     0,24%

 T    7,26%  O   5,14%  V   2,15%  J   0,89%  K,W   0%
--- ------- --- ------ --- ------ --- ------ ----- ------

et de l'anglais.

--- ------- --- ------ --- ------ --- ------ ----- ------
 E   12,56%  I   7,24%  D   3,99%  P   1,91%  V     1,00%

 T    9,15%  S   6,59%  C   3,18%  W   1,89%  K     0,63%

 A    8,08%  R   6,42%  U   2,79%  G   1,80%  X     0,21%

 O    7,47%  H   5,27%  M   2,60%  B   1,67%  J     0,14%

 N    7,38%  L   4,04%  F   2,17%  Y   1,65%  Q     0,09%
 
                                              Z     0,07%
--- ------- --- ------ --- ------ --- ------ ----- ------

Trouver la clef de chiffrement des textes suivants.

> mywjbhibjgyvgyiatirdbnrijgniomgntifgoybwvbgwyijywjyi
> oybjbmfymidgxywdgoaghigagnjhigmgntifgoybwvmgitimgnti
> fgoybwoyktijmgntifgoybwxyoaqgmgntifgoybwmboggjaygjgo
> yaqyaiwxgjntwvbgwtibmrgijgjgwyyijywjhibmrgijynyzyatw

> ◱◦◶◵◦◵◳◦◲◶◦◮◢◷◪◭◭◦◯◦◴◵◱◢◴◩◪◱◩◰◱◮◢◪◴◪◭◺◢◲
> ◶◢◯◥◮◦◮◦◱◭◶◴◪◦◶◳◴◵◢◨◨◦◳◴◭◦◱◭◶◴◱◳◦◴◦◯◵◦◴◵
> ◴◢◯◴◯◶◭◥◰◶◵◦◤◦◭◶◪◲◶◪◴◪◨◯◦◱◢◳◵◰◶◵◷◪◷◦◭◦◳◰
> ◪◪◭◺◢◢◶◴◴◪◭◢◧◳◢◯◤◦◢◶◹◧◳◢◯◢◪◴◮◢◪◴◴◰◯◴◵◺◭◦
> ◦◴◵◯◦◵◵◦◮◦◯◵◱◭◶◴◥◦◮◰◥◦◭◦◴◰◪◳◪◭◯◺◢◳◪◦◯◢◧◢
> ◪◳◦◢◱◢◳◵◱◳◦◯◥◳◦◥◦◴◷◦◳◳◦◴◱◭◢◤◦◥◶◮◢◳◤◩◦◴◪◭
> ◦◴◱◢◳◦◯◵◴◥◦◧◳◢◯◰◪◴◴◢◣◴◦◯◵◦◯◵◪◭◺◢◶◳◢◴◢◯◴◥
> ◰◶◵◦◶◯◴◲◶◢◵◰◳◨◢◯◪◴◦◯◰◶◴◺◥◦◴◤◦◯◥◳◰◯◴◲◶◦◭◲
> ◶◦◴◱◢◤◬◴◥◦◬◳◰◦◯◦◤◰◶◵◢◯◵◥◶◳◰◤◬◦◵◧◶◮◢◯◵◥◦◴
> ◫◰◪◯◵◴◪◭◯◺◢◶◳◢◴◶◳◦◮◦◯◵◱◢◴◥◦◧◪◭◭◦◴◮◢◪◴◭◢◭
> ◤◰◰◭◦◵◭◢◥◳◰◨◶◦◤◦◴◵◥◦◫◢◣◪◦◯◤◢◳◯◰◶◴◴◰◮◮◦◴◥
> ◦◴◳◦◣◦◭◭◦◴◴◢◯◴◤◢◶◴◦◴◥◦◱◶◪◴◲◶◦◭◢◳◨◦◯◵◯◰◶◴
> ◭◦◴◢◦◯◭◦◷◦◦◴◤◦◳◵◢◪◯◴◷◪◷◦◯◵◮◦◮◦◥◢◯◴◥◦◴◤◢◮
> ◪◰◯◴◦◵◧◰◯◵◥◦◭◢◵◦◤◩◯◰◥◢◯◴◭◢◧◰◳◦◵◦◵◤◩◢◲◶◦◫
> ◦◶◯◦◢◥◢◯◴◴◰◯◱◭◢◤◢◳◥◶◯◵◴◩◪◳◵◢◭◦◧◧◪◨◪◦◥◶◤◩
> ◦◮◦◮◦◴◪◭◢◱◭◶◱◢◳◵◴◰◯◵◪◯◤◢◱◢◣◭◦◴◥◦◱◰◶◷◰◪◳◦
> ◹◱◭◪◲◶◦◳◲◶◪◪◭◦◴◵◦◯◧◦◳◮◦◴◥◢◯◴◭◦◶◳◴◤◩◢◮◣◳◦
> ◴◫◦◢◯◣◦◯◰◪◵◦◵◯◪◤◰◭◢◴◦◤◰◶◵◦◯◵◭◦◴◱◪◯◬◧◭◰◺◥
> ◦◯◳◦◷◢◯◵◥◦◧◰◯◥◦◳◶◯◨◳◰◶◱◦◥◦◳◰◤◬◱◰◶◳◱◰◶◷◰◪
> ◳◷◪◷◳◦◥◦◭◦◶◳◮◶◴◪◲◶◦◮◢◪◴◱◦◳◥◶◴◦◯◵◳◦◭◦◴◵◳◰
> ◪◴◢◷◦◯◶◦◴◪◭◴◦◯◵◦◯◥◦◯◵◭◢◷◪◭◭◦◭◦◶◳◤◩◶◤◩◰◵◦
> ◳◲◶◶◯◷◳◢◪◮◦◵◪◦◳◤◦◴◵◢◳◤◩◪◵◦◤◵◦◰◶◱◳◰◧◦◴◴◦◶
> ◳◥◦◮◢◵◩◦◮◢◵◪◲◶◦◴◯◦◴◰◶◴◭◦◴◪◨◯◦◥◶◷◴◰◶◴◭◦◴◪◨◯◦◥◶◷

Trouvez une façon raisonnable et compacte d'écrire cette clef de
chiffrement. Dans cette notation, comment écrit-on la clef du chiffre
de César?


# Implantation d'un chiffrement monoalphabétique

Dans la suite, on ne manquera pas de consulter la
[doc de l'API Java](http://docs.oracle.com/javase/6/docs/api/)
lorsqu'on aura besoin de connaître les méthodes liées à un objet. Les
paquets qui nous intéressent sont tout simplement `java.lang` et
`java.io`.

Créez un fichier `Mono.java` ayant la structure suivante

~~~ {.java}
import java.io.*;   // Pour les lectures de fichiers

/*
   Cette classe implante un chiffreur-dechiffreur
   monoalphabetique
*/
public class Mono {
	private char[] clef;

	public Mono(String clef) {
		// Stocke la clef
		// et initialize l'objet
	}

	public String chiffre(String clair) {
		// Chiffre un texte clair
		// (avec la clef stockee)
		return clair; 
	}

	public String dechiffre(String chiffre) {
		// Dechiffre un texte chiffre
		// (avec la clef stockee)
		return chiffre;
	}

	public static void main(String[] args) throws IOException {
		// 1. Lit les arguments sur la ligne de commande
		// 2. Cree un objet Mono avec la clef passee en argument
		// 3. Ouvre le fichier clair ou chiffre
		// 4. Chiffre/dechiffre
	}
}
~~~

On veut écrire un programme qui prend en paramètre une clef et le nom
d'un fichier et qui affiche à l'écran le résultat du chiffrement ou
déchiffrement du fichier.

Voici un exemple d'invocation:

    $ java Mono cdefghijklmonpqrstuvwxyzab rings.txt --chiffre
	'aqw vtkgf vq ikxg wu vjg uokr qpeg dghqtg cpf hckogf, htqfq,' jg
	uckf. 'vjku vkng aqw jcxg pgctoa uweeggfgf, dwv aqw jcxg hckogf
	cickp. kv ycu pqv ucn, vjqwij, vjcv icxg aqw cyca vjku vkng, dwv
	icpfcoh jknugoh!'


### Lecture des paramètres de la ligne de commande

Comme en C, les paramètres de la ligne de commande sont passés au
`main` à travers un tableau de chaînes de caractères. En C on écrit:

~~~ {.c}
void main(int combien, char[][] params)
~~~

où la variable `params` est un tableau de chaînes (on se souvient
qu'une chaîne de caractères a type `char[]` en C) et la variable
`combien` est sa longueur.  Le tableau `params` contient tous les mots
tapés dans la ligne de commande, ainsi si on avait un programme C
`mono` que l'on invoquait ainsi

    ./mono cdefghijklmonpqrstuvwxyzab rings.txt --chiffre

`params[0]` vaudrait `./mono`, `params[1]` vaudrait
`cdefghijklmonpqrstuvwxyzab` et ainsi de suite. En java il y a deux
différences fondamentales

~~~ {.java}
public static void main(String[] params)
~~~

- Le champs `length` de tout tableau permet d'obtenir sa longueur, pas
  besoin donc d'avoir l'argument `combien`.
- Le tableau `params` démarre au premier argument, et pas au nom du
  programme. Ainsi dans l'exemple précédent `params[0]` vaudrait
  `cdefghijklmonpqrstuvwxyzab`, `params[1]` vaudrait `rings.txt`,
  etc.
  
Dans le `main`, écrivez du code qui récupère les paramètres de la
ligne de commande et initialise des variables locales. Le premier
paramètre doit contenir la clef (il s'agit d'une chaîne de 26
caractères), le deuxième doit être le nom d'un fichier (encore une
chaîne de charactères) et le troisième (facultatif) doit être un
*switch* qui indique si chiffrer ou déchiffrer (s'il n'est pas
renseigné, on chiffre par défaut). S'il n'y a pas assez de paramètres,
on affiche un message d'erreur et on termine.

Pour vérifier que votre programme lit correctement les paramètres,
affichez-les à l'écran après les avoir lus.


### Creation de l'objet Mono

Implantez le constructeur de la classe `Mono` et créez un objet de ce
type dans le main. Pour cela, vous allez avoir besoin de convertir une
chaîne de caractères en un tableau de caractères. Allez voir la doc de
la classe `String` pour savoir comment faire.

### Lecture du fichier

Pour lire le fichier nous devons créer un objet un peut spécial appelé
`BufferedStreamReader` (qui fait partie du paquet `java.io`). En
supposant que le variable `fichier` soit une chaîne contenant le nom
du fichier a ouvrir, on le crée ainsi:

    BufferedStreamReader in = new BufferedStreamReader(new FileReader(fichier));

Ensuite la lecture du fichier se fait avec la méthode `readLine()` du
`BufferedStreamReader`. Cette méthode renvoie une chaîne de caractères
si le fichier contient des données à lire, ou la valeur `null` quand
on est arrivés à la fin du fichier.

Écrire une boucle qui lit le fichier à chiffrer/déchiffrer, qui
chiffre ou déchiffre la ligne selon les paramètres passés, et qui
affiche à l'écran le résultat.

Testez votre fonction. Bien évidemment le résultat affiché doit être
identique au fichier original, vu que n'avez pas encore codé les
méthodes `chiffre` et `dechiffre`.


### Chiffrer

Écrivez maintenant la méthode `chiffre`. Pour simplifier les choses,
on va commencer par convertir tout le texte en minuscule. Pour cela,
la méthode `toLowerCase()` de la classe `String` vous sera utile.

Lisez la chaîne en entrée caractère par caractère et remplacez
celui-ci par le caractère qui lui correspond dans la clef. Si le
caractère n'est pas compris entre `a` et `z`, ignorez-le.

On rappelle que le type `char` correspond aux caractères ASCII encodés
sur un octet. On peut y appliquer des opérations comme sur des entiers
(ce qui va les transformer en `int`); par exemple l'expression
suivante vaut `true`:

~~~ {.java}
'c' == 'a' + 2
~~~

Ceci fonctionne car les caractères ASCII de `a` à `z` se trouvent dans
des positions consécutives.

Attention, écrire

~~~ {.java}
char caractere = 'a' + 2;
~~~

produira un warning ("possible loss of precision"). Pour éviter cela,
penser à reconvertir le résultat de l'addition en un `char` avec un
*cast* explicite:

~~~ {.java}
char caractere = (char)('a' + 2);
~~~

Testez votre fonction.


### Déchiffrer

Écrivez maintenant la méthode `dechiffre`. Utilisez vos connaissances
en matière de recherche dans un tableau pour calculer la fonction
inverse du chiffrement.

Vérifiez votre fonction en déchiffrant un texte précédemment chiffré.

Voici la solution complète. Ne la lisez pas avant d'avoir terminé.

<div style="overflow:hidden;height:6ex"
onclick="if (this.style.height != 'auto') this.style.height='auto'; else this.style.height='6ex'">

~~~ {.java}
import java.io.*;       // Cliquez ici pour lire la solution

/*
   Cette classe implante un chiffreur-dechiffreur
   monoalphabetique
*/
public class Mono {
	private char[] clef;

	public Mono(String clef) {
		this.clef = clef.toCharArray();
	}

	public String chiffre(String clair) {
		clair = clair.toLowerCase();
		String chiffre = "";
		for (int i = 0; i < clair.length(); i++) {
			int cl = clair.charAt(i);
			int ch = cl - 'a';
			if (0 <= ch && ch < clef.length)
				chiffre += clef[ch];
		}
		return chiffre;
	}

	public String dechiffre(String chiffre) {
		chiffre = chiffre.toLowerCase();
		String clair = "";
		for (int i = 0; i < chiffre.length(); i++) {
			char ch = chiffre.charAt(i);
			int pos = -1;
			for (int j = 0; j < clef.length; j++)
				if (clef[j] == ch) pos = j;
			if (pos >= 0)
				clair += (char)('a' + pos);
		}
		return clair;
	}

	public static void main(String[] args) throws IOException {
		if (args.length < 2) {
			System.out.println("Pas assez d'arguments");
			System.exit(0);
		}
		String clef = args[0];
		String file = args[1];
		Boolean decrypt = false;
		if (args.length >= 3 && args[2].equals("--dechiffre"))
			decrypt = true;
		
		Mono mono = new Mono(clef);
		
		BufferedReader in = new BufferedReader(new FileReader(file));
		
		String line;
		while ((line = in.readLine()) != null) {
			if (decrypt)
				System.out.println(mono.dechiffre(line));
			else
				System.out.println(mono.chiffre(line));
		}
	}
}
~~~

</div>


### Un peu de complexité

Il y a au moins deux façons d'implanter la méthode `dechiffre`. La
première fait une recherche dans le tableau `clef` pour chaque
caractère du texte chiffré; c'est la façon dont c'est implanté dans la
solution ci-dessus. La deuxième commence par créer le *tableau
inverse* de la clef (ce qui revient à calculer l'inverse d'une
permutation) et puis utilise le tableau inversé de la même façon que
`chiffre` accède au tableau direct.

Combien de lectures dans les tableaux (direct et inversé) fait chacune
des méthodes en moyenne (en imaginant que les caractères du chiffré
soient uniformément répartis, ce qui n'est évidemment pas le cas)?
Laquelle est plus efficace? Si votre implantation ne le fait pas déjà,
modifiez-la pour utiliser la méthode la plus efficace.


# Analyse statistique

Créez un programme `Stat.java` qui

1. Compte le nombre d'occurrences des caractères dans un fichier donné.
2. Compile une liste des clefs les plus probables (pour l'alphabet français) en se basant sur l'analyse du point précédent.
3. Essaye de déchiffrer avec ces clefs et propose les résultats à l'utilisateur. Vous pouvez recycler le code écrit auparavant en important la classe `Mono` avec `import Mono;` (pour cela, il faut que les deux fichiers soient au même endroit).

Appliquez votre programme au texte suivant

> grmttvhvrhdhtvhhbehnh vxivvgcdmihqhcmqhnrfh fivagmairaihvvasnrrm
> hgimahtmdahbirrqtva aioaarmvbrbqhaalv bbnrgqhhdidtcramid
> niqabsvhqlsfhnqqj
> ydamnbhiraoaqtcdiihrgqmgsmsmbthzrqioqohghmitachdqtthvdr
> taydhtthehohmaqvnbrqrhhiqtthwagqmatsmxihgzvaohbaiihmiqsm
> ydhvibhydhbhtaohdinqrhrziaqiqtgabkqmathghmi
> vdrtksmmhdrehmadraqvzdthtdqazzrhmnrhnaqtthdrvqtmh
> gqmihrrsxhazavhiqtbsmiqmdanhvhzarthrtdqggh
> bhvibhydhmsdvazzhtsmvdmbrjzisxragghnqvaqiqtnamvthydhtth
> vhmvhvibabkvsdvnhvthiirhvlrsdqtthvnhvvhqmhiydq
> bsmohmalthghminqvzsvhvcsrghraqhmidmhzkravhqmihttqxqlthydamneh
> zhmvhydqtjatzhdiirhthwztqbaiqsmsdtqmnqbaiqsmndmhxramnh nbsdohrih
> zsdrgsmbsgzihehzhmvaqvydqtmjaoaqialvstdghmirqhmgaqveh
> xarnaqzrdnhgghmigsmszqmqsm
> thzrschvvhdrzrqiatsrvthtqorhhithzarbkhgqmhithvbsgzaraisdv thvnhdw
> bhvnhdwbrqidrhvmhvsmizavnhtagghgaqmnqiqtth
> brjzisxragghhvizsvirqhdradtqorhhiehmosqvdmhzrhdoh
> qrrcraxalthhmhcchitazrhgqrhthiirhhvidmhnsdlthgydsm
> bkhrbkhraqioaqmhghminamvthtqorhnhidrthvsmbarhtthmhcdiaesdih
> tatzkalhiqvtamnaqvydadwqovqbthaqmvqnsmbqtjaadgsqmv
> nhdwbhmivamvhmirhthgamdvbrqihithnsbdghmi
> bhtaehmbsmoqhmvghzardiavvhptsxqydh
> ehvdqvnsmbbsmndqizhmvhrrhzrqigsmsmbthydhtdmnhv
> zsvvhvvhdrvnhbhtqorhadrairabbhvbarabirhvgjvirqhdwgaqvydq
> nqalthiaqibhzsvvhvvhdrmadraqiqtzsqmigqvvsmmsghmydhtydh
> hmnrsqihmbhgamdvbrqi
> gsmsmbthrhthoavhvtdmhiihvzrqidmhcsrihtsdzhhizavva
> vsqxmhdvhghmihmrhodhthvzrhgqrhvzaxhvndtqorhadohrvsnhta
> vhbsmnhbhtthndcadwiqirhqtnbsdorqidmhvsrihnhgabdthydq
> caqvaqitshqtthcchindmhibkhnhmbrhbhzhmnamihmjrhxarnamr
> nhzrvsmnqviqmxdaqiydhtydhvbarabirhvnhgqhccabvgsmsmbth
> bsgzrqiydhtiaqithzsqmiqmirhvvamiqtvabkarmansmbvdrta
> gabdthhivaxrsvvhtsdzhaqnamiqtcqmqizarrhbsmmairhthvvqxmhv
> ydhosqbqbarabirhvrdmqydhydqttdivamvkvqihr
> armhvafmdvvhggvbrqaiqtndmismirqsgzkamigaqvbhvidmmsg
> bhtahidmmsgqvtamnaqvhmbsrhbhtdqndmvaoamindwoqvndm atbkqgqvihbtlrh
> ehrhxarnaqgsmsmbthaohbdmhbhriaqmhangqraiqsm
> bhvatbkqgqvihvrhzrqiqtaoqbhmmhlabsmtdtthzarabhtvhiaqhmi
> thvorqialthvthvvhdtvvaoamivnhthdrzsydhqtvsmicaqinhv
> nbsdohrihvnsmimsdvaosmvthnrsqinirhismmvzsdrydsqbh
> vafmdvvhggmadraqiqtzavhmcsdqvsdvbhiqmbsgzrkhmvqlthbrjzisxraggh
> ydhtydhvdrzrhmamihqmohmiqsmbhtansqiirhaqmvqbhtahvi
