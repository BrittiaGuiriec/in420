UTF-16 est un standard de codage √† longueur variable pour Unicode, successeur de UCS-2. Il a √©t√© introduit par le standard ISO/IEC 10646 afin de d√©passer les limitations de UCS-2 en mati√®re de caract√®res repr√©sentables. Il est en train d'√™tre d√©finitivement remplac√© par [UTF-8]().


# Unicode et UCS-2

Unicode est un standard permettant de repr√©senter les symboles d'une grande partie des alphabets connus, plus d'autres utilis√©s dans diff√©rentes branches (math√©matique, ing√©nierie, etc.).

√Ä chaque symbole Unicode est associ√© un entier, appel√© en anglais son *code point*, dans l'intervalle de `0x0` √† `0x10FFFF` (`0x` indique un nombre hexad√©cimal). Les caract√®res Unicode sont souvent repr√©sent√©s par `U+` suivi du code point, par exemple `U+0058` est le caract√®re 'X' de l'alphabet latin.

Unicode est subdivis√© en dix-sept *plans* (*planes* en anglais), de 2^16^ code points chacun, ce qui fait un total de 1.112.114 codes possibles (en ce moment, environ 10% de ces codes sont utilis√©s). Parmi les plans on distingue le *Basic Multilingual Plane (BMP)*, contenant les symboles les plus courants et dont les code points vont de `U+0000` √† `U+FFFF`, le *Supplementary Multilingual Plane*, allant de `U+10000` √† `U+1FFFF`, et le *Supplementary Ideographic Plane*, allant de `U_20000` √† `U+2FFFF`. Les symboles ASCII, plus pr√©cis√©ment ceux du jeu ISO-8859-1, font partie du Basic Multilingual Plane et ont code points de `U+0000` √† `U+00FF`.

L'encodage UCS-2 est capable de repr√©senter seulement les codes points du BMP, et fait cela en encodant les caract√®res par leur code point sur deux octets.


# Codes subrog√©s et UTF-16

UTF-16 est un standard de codage qui permet de repr√©senter tous les code points de Unicode. Les codes points du BMP sont repr√©sent√©s sur 2 octets, comme dans UCS-2, les codes points des plans suppl√©mentaires sont repr√©sent√©s sur 4 octets.

Afin de permettre un d√©codage unique, une partie du BMP, la plage allant de `U+D800` √† `U+DFFF`, est r√©serv√©e pour ce que l'on appelle *codes subrog√©s*. Ces codes ne repr√©sentent aucun vrai symbole¬†: ils sont utilis√©s pour encoder les code points des symboles des plans suppl√©mentaires.

La pr√©sence des codes subrog√©s fait de UTF-16 un *code instantan√©*, en ce sens que n'importe quelle paire d'octets au milieu d'un flux UTF-16 peut √™tre imm√©diatement reconnue comme √©tant un symbole du BMP, ou bien un code subrog√© (*haut* ou *bas*) faisant partie d'un symbole encod√© sur 4 octets.


## Algorithme

La longueur variable impose la n√©cessit√© de d√©finir un algorithme de codage/d√©codage pour UTF-16. √âtant donn√© un code point Unicode, son encodage UTF-16 est encod√© sur 2 ou 4 octets comme suit:

- Si le code point appartient au BMP, il est √©crit tel quel dans 2 octets. Ceci inclut tous les code points de `U+0000` √† `U+D7FF` et de `U+E000` √† `U+FFFF`, mais exclut les codes subrog√©s de `U+D800` √† `U+DFFF` qui sont r√©serv√©s pour un usage interne.

- Si le code point n'appartient pas au BMP, sont code est compris entre `U+10000` et `U+10FFFF`. L'algorithme proc√®de ainsi:

    - On soustrait `0x10000` du code point, obtenant un code compris entre `0x0` et `0xFFFFF`.
    - Le r√©sultat de l'op√©ration pr√©c√©dente tient sur 20 bits. On coupe les 20 bits en deux blocs de 10 bits chacun, appel√©s *partie haute* (les bits plus significatifs) et *partie basse* (les bits moins significatifs).
    - On ajoute les bits haut √† `0xD800`, en obtenant ainsi un code subrog√© compris entre `U+D800` et `U+DBFF`, appel√© *subrog√© de t√™te*.
    - On ajoute les bits bas √† `0xDC00`, en obtenant ainsi un code subrog√© compris entre `U+DC00` et `U+DFFF`, appel√© *subrog√© de queue*.

    Le symbole Unicode est encod√© par le subrog√© de t√™te √©crit sur 2 octets, suivi par le subrog√© de queue √©crit sur 2 octets.


## Exemple

Les symboles '0' (zero) et '‚Ç¨' (euro) font partie du BMP et on codes, respectivement, `U+0030` et `U+20AC`. Ils sont encod√©s par UTF-16 sur deux octets, respectivement (`0x00`, `0x30`) et (`0x20`, `0xAC`).

Le symbole üòÉ a pour code point `U+1F603`. Voici l'algorithme appliqu√© pas par pas.

- On soustrait `0x10000`, ce qui donne `0xF603`.
- On coupe `0xF603` en deux moiti√©s de 10 bits chacune. La partie haute donne `0x03D`, et la partie basse `0x203`.
- Le subrog√© de t√™te est obtenu en additionnant `0x03D` √† `0xD800`, ce qui donne le subrog√© `U+D83D`.
- Le subrog√© de queue est obtenu en additionnant `0x203` √† `0xDC00`, ce qui donne le subrog√© `U+DE03`.

Le symbole üòÉ est alors encod√© par la suite de quatre octets (`0xD8`, `0x3D`, `0xDE`, `0x03`).

